
\section{Pseudoalgoritmos.}
En esta sección vamos a ver algunos pseudoalgoritmos referentes a los algoritmos que hemos implementado. Nos vamos a centrar en aquellos que tienen mayor complejidad e interés, sin entrar en gran detalle. \\

En concreto, vamos a ver los pseudoalgoritmos para el algoritmo de Dehornoy (que se descompone en varios algoritmos auxiliares), el algoritmo que nos permite comprobar si dos trenzas dadas (o sus cierres) son o no equivalentes entre sí y el algoritmo que nos permite comprobar si una trenza dada (o su cierre) es equivalente a la trenza trivial.\\

\begin{center}
	\textbf{Algoritmo Dehornoy para trenzas.}
\end{center} 
Vamos a ir viendo los algoritmos auxiliares y concluiremos con el propio algoritmo de Dehornoy. Recordemos que este algoritmo se explica con detalle en la sección \ref{deh}.\\

Mediante el algoritmo Simplifica eliminamos ocurrencias de tipo $\sigma_{i}^{e}\sigma_{i}^{-e}, e \in$ \{-1,1\} de una palabra que representa a cierta trenza. 

\begin{alg}
	\textbf{Algoritmo Simplifica}(indices\_braid)\\
	ENTRADA: indices\_braid (cadena de enteros que representa los cruces de una trenza)\\
	SALIDA: \hspace{0.4cm} braid\_aux (cadena auxiliar para mejor representacion visual) \\
    \hspace*{2.2cm} nueva\_braid (cadena de enteros que representa los cruces de la trenza tras eliminar dos cruces opuestos)\\
    \hspace*{2.2cm} encontrado (bool para indicar si se produce simplificación)
	
	\lstset{language=Matlab, breaklines=true, basicstyle=\ttfamily\small ,numbers=left, stepnumber=1, numberstyle=\color{blue}}
\begin{lstlisting}
   Recorro los cruces de indices_braid
   Si hay dos cruces seguidos con signos opuestos, creo una copia de indices_braid y elimino dichos cruces. 
\end{lstlisting}
\end{alg}

\newpage
Haciendo uso del siguiente algoritmo podremos encontrar las posiciones que delimitan un $\sigma_{minimo}$-handle.
\begin{alg}
	\textbf{Algoritmo encuentra\_handle}(indices\_braid, minimo)\\
	ENTRADA: indices\_braid (cadena de enteros que representa los cruces de una trenza)\\
	\hspace*{2.2cm} minimo (generador de handle a encontrar) \\
	SALIDA: \hspace{0.4cm} pos1 (posición inicial del handle encontrado) \\
	\hspace*{2.2cm} pos2 (posición final del handle encontrado)
	
	\lstset{language=Matlab, breaklines=true, basicstyle=\ttfamily\small ,numbers=left, stepnumber=1, numberstyle=\color{blue}}
\begin{lstlisting}
   Recorro los cruces de indices_braid
   Si hay un cruce generado por el elemento minimo, me quedo con esa posicion como pos1 y su signo. Sino fin.
   Si encuentro un cruce generado por el elemento minimo con signo opuesto, me quedo con esa posicion como pos2.
\end{lstlisting}
\end{alg}

\bigskip
Haciendo uso del algoritmo reduccion\_base aplicamos una reducción local a la trenza representada por indices\_braid sobre el $\sigma_{minimo}$-handle que está situado entre las posiciones pos1 y pos2. Es importante destacar el hecho de que este $\sigma_{minimo}$-handle  no contiene $\sigma_{minimo+1}$-handle.
\begin{alg}
	\textbf{Algoritmo reduccion\_base}(indices\_braid, minimo, pos1, pos2 )\\
	ENTRADA: indices\_braid (cadena de enteros que representa los cruces de una trenza)\\
	\hspace*{2.2cm} minimo (generador de handle) \\
	\hspace*{2.2cm} pos1 (posición inicial del handle) \\
	\hspace*{2.2cm} pos2 (posición final del handle)\\
	SALIDA: \hspace{0.4cm} braid\_aux2 (cadena auxiliar para mejor representación visual) \\
	\hspace*{2.2cm} nuevo (cadena de enteros que representa los cruces de la trenza tras aplicar la reducción local al $\sigma_{minimo}$-handle entre pos1 y pos2)\\
	\hspace*{2.2cm} simplificado2 (bool auxiliar para mejor representación visual)
	
	\lstset{language=Matlab, breaklines=true, basicstyle=\ttfamily\small ,numbers=left, stepnumber=1, numberstyle=\color{blue}}
\begin{lstlisting}
   Creo vector_auxiliar
   Recorro los cruces de indices_braid desde pos1 hasta pos2
   Si hay un cruce generado por el elemento (minimo+1) aniado al vector_auxiliar los 3 cruces correspondientes. Sino, aniado el mismo cruce. 
   Creo vector_nuevo con los elementos desde inicio de indices_braid hasta pos1, vector_auxiliar, y los elementos desde pos2 hasta final de indices_braid.
   Si indices_braid y vector_auxiliar tienen distinto tamanio, asigno a braid_aux2 una cadena con ciertos ceros para mejor visualizacion.
\end{lstlisting}
\end{alg}

Estos algoritmos auxiliares no se proporcionan para uso directo al usuario ya que el realmente interesante es el algoritmo de Dehornoy, pero sí podrían ser usados. Veamos entonces el algoritmo de Dehornoy.\\

\newpage
\begin{alg}
	\textbf{Algoritmo dehornoy}(br, N\_cortes, Radio, representar)\\
	ENTRADA: br (trenza)\\
	\hspace*{2.2cm} N\_cortes (numero de cortes de las cadenas de la trenza)\\
	\hspace*{2.2cm} Radio (radio de las cadenas de la trenza)\\
	\hspace*{2.2cm} representar (bool para representar las equivalencias de la trenza)\\
	SALIDA: \hspace{0.4cm} es\_trivial (bool que nos indica si la trenza dada es o no trivial) \\
	\hspace*{2.2cm} trenza\_final (cadena de enteros que representa a la trenza reducida equivalente a br)
	
	\lstset{language=Matlab, breaklines=true, basicstyle=\ttfamily\small ,numbers=left, numbersep=-2pt, numberstyle=\color{blue}}
\begin{lstlisting}
   Si numero_argumentos=1 -> N_cortes=20, Radio=0.5, representar=1.
   indices_braid = cadena de enteros que representa a la trenza
   Si br tiene cadenas a la derecha triviales, las eliminamos visualmente.
   Mientras queden handles en la trenza dada...
	   Obtenemos la palabra libremente reducida de indices_braid.
	   Si no se produce reduccion...
		   minimo = generador principal de indices_braid.
		   [pos1,pos2]=encuentra_handle(indices_braid,minimo)
		   Si pos1 y pos2 son posiciones validas....
			   Busco primer subhandle a realizar en el handle.
			   Actualizo pos1 y pos2
			   Aplico reduccion_base a dicho subhandle.
	   Creo matriz con secuencia de palabras generadas en el proceso.
   Si representar, muestro las trenzas usando dicha matriz.			   
\end{lstlisting}
\end{alg}

Finalmente cabe comentar que el algoritmo de Dehornoy se podrá aplicar sobre trenzas cerradas. El proceso que se realizará internamente será exactamente el mismo que para trenzas, ya que el cerrar la trenza no aporta información nueva para el algoritmo de Dehornoy. \\

\bigskip
\begin{center}
	\textbf{Algoritmo de equivalencia para trenzas.}
\end{center} 

\begin{alg}
	\textbf{Algoritmo equivalentes}(br1,br2,explicacion)\\
	ENTRADA: br1 (trenza1)\\
	\hspace*{2.2cm} br2 (trenza2)\\
	\hspace*{2.2cm} explicacion (bool para mostrar mensajes explicativos)\\
	SALIDA: \hspace{0.4cm} equi (bool para indicar si br1 y br2 son o no equivalentes)
	
	\lstset{language=Matlab, breaklines=true, basicstyle=\ttfamily\small ,numbers=left, stepnumber=1, numberstyle=\color{blue}}
\begin{lstlisting}
   Si numero_argumentos=2 -> explicacion=0.
   Obtengo exponente de ambas trenzas.
   Si son distintos -> No son equivalentes. Finalizo
   Obtengo permutacion de ambas trenzas.
   Si son disintas -> No son equivalentes. Finalizo
   Genero trenza_auxiliar = br1br2^{-1}.
   Aplico Dehornoy a trenza_auxiliar y obtengo final_braid.
   Si final_braid no es vacia -> No son equivalentes. 
   Sino -> Si explicacion=1 -> represento secuencia de trenzas de dehornoy.
    
\end{lstlisting}
\end{alg}

\bigskip
\begin{center}
	\textbf{Algoritmo de equivalencia para trenzas cerradas.}
\end{center} 

\begin{alg}
	\textbf{Algoritmo equivalentes}(br1,br2,explicacion)\\
	ENTRADA: br1 (trenza cerrada 1)\\
	\hspace*{2.2cm} br2 (trenza cerrada 2)\\
	\hspace*{2.2cm} explicacion (bool para mostrar mensajes explicativos)\\
	SALIDA: \hspace{0.4cm} equi (bool para indicar si br1 y br2 son o no equivalentes)
	
	\lstset{language=Matlab, breaklines=true, basicstyle=\ttfamily\small ,numbers=left, stepnumber=1, numberstyle=\color{blue}}
\begin{lstlisting}
   Si numero_argumentos=2 -> explicacion=0.
   Si el numero de enlaces de br1 y de br2 son disintos -> No son equivalentes.    Finalizo
   Si equivalentes@trenza(br1,br2) son equivalentes -> sus cierres son equivalentes.
   Sino ->   
   	Obengo polinomio de Alexander de ambas trenzas.
	Si son distintos -> No son equivalentes.
	Sino -> No sabemos si son o no equivalentes. 
\end{lstlisting}
\end{alg}

\bigskip
\begin{center}
	\textbf{Algoritmo para ver trivialidad de trenza.}
\end{center} 

\begin{alg}
	\textbf{Algoritmo es\_trivial}(br,explicacion)\\
	ENTRADA: br (trenza)\\
	\hspace*{2.2cm} explicacion (bool para mostrar mensajes explicativos)\\
	SALIDA: \hspace{0.4cm} equi (bool para indicar si br1 es o no equivalente a la trenza trivial)
	
	\lstset{language=Matlab, breaklines=true, basicstyle=\ttfamily\small ,numbers=left, stepnumber=1, numberstyle=\color{blue}}
\begin{lstlisting}
   Si numero_argumentos=1 -> explicacion=0.
   Creo br2 = trenza trivial. 
   Aplico algoritmo equivalentes para br y br2.
\end{lstlisting}
\end{alg}

\newpage
\begin{center}
	\textbf{Algoritmo para ver trivialidad de trenza cerrada.}
\end{center} 

//TENGO QUE PONER LOS ALGORITMOS AUXILIARES Y TAL................
\begin{alg}
	\textbf{Algoritmo es\_trivial}(br,explicacion)\\
	ENTRADA: br (trenza)\\
	\hspace*{2.2cm} explicacion (bool para mostrar mensajes explicativos)\\
	SALIDA: \hspace{0.4cm} equi (bool para indicar si br1 es o no equivalente a la trenza trivial)
	
	\lstset{language=Matlab, breaklines=true, basicstyle=\ttfamily\small ,numbers=left, stepnumber=1, numberstyle=\color{blue}}
	\begin{lstlisting}
	Si numero_argumentos=1 -> explicacion=0.
	Creo br2 = trenza trivial. 
	Aplico algoritmo equivalentes para br y br2.
	\end{lstlisting}
\end{alg}